{
    "version": "https://jsonfeed.org/version/1",
    "title": "ay的博客",
    "subtitle": "ay的博客",
    "icon": "http://gardencavy.site/images/favicon.ico",
    "description": "ay的博客",
    "home_page_url": "http://gardencavy.site",
    "items": [
        {
            "id": "http://gardencavy.site/java/",
            "url": "http://gardencavy.site/java/",
            "title": "java",
            "date_published": "2025-01-14T16:00:00.000Z",
            "content_html": "<p>welcom to</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p 2=\"\">1 + 1 = 2<br>\n1 + 1 = 2 \\frac{1}</p>\n",
            "tags": [
                "java",
                "java"
            ]
        },
        {
            "id": "http://gardencavy.site/java%E7%AC%94%E8%AE%B0/",
            "url": "http://gardencavy.site/java%E7%AC%94%E8%AE%B0/",
            "title": "java笔记",
            "date_published": "2025-01-14T16:00:00.000Z",
            "content_html": "<h3 id=\"面向对象\"><a class=\"anchor\" href=\"#面向对象\">#</a> 面向对象</h3>\n<h4 id=\"对象\"><a class=\"anchor\" href=\"#对象\">#</a> 对象</h4>\n<p>1、对象是啥？如何得到<br>\n对象就是一种特殊的数据结构。对象是用类 new 出来的，有了类就可以创建出对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 类名&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>、变量，用来说明对象可以处理什么数据</span><br><span class=\"line\">\t<span class=\"number\">2</span>、方法，描述对象有什么功能</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"构造器\"><a class=\"anchor\" href=\"#构造器\">#</a> 构造器</h4>\n<p>构造器是什么样子的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造器有什么特点？<br>\n创建对象时，对象回去调用构造器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Student</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br></pre></td></tr></table></figure>\n<p>构造器的常见应用场景<br>\n创建对象时，同时完成对对象成员变量的初始化赋值</p>\n<p>构造器的注意事项<br>\n 1、类默认自带一个<mark>无参构造器</mark><br>\n 2、如果为类定义了一个有参数构造器，类默认的无参构造器就<mark>没有了</mark>，此时如果还想使用无参构造器，就必须手写一个无参构造器出来。</p>\n<hr>\n<h4 id=\"this关键字\"><a class=\"anchor\" href=\"#this关键字\">#</a> this 关键字</h4>\n<p>this 就是一个变量，可以用在方法中，来拿到当前对象<br>\n那个对象调用方法，this 就指向哪一个对象，也就是拿到哪一个对象</p>\n<p>this 可以用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突问题的</p>\n<hr>\n<h4 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h4>\n<p>封装就是用类设计对象处理某一个事物的数据时，应该要把处理的数据，以及处理这些数据的方法设计到一个对象中去。<br>\n面向对象的三大特征：封装，继承，多态</p>\n<p>封装的设计规范：合理隐藏，合理暴露</p>\n<p>公开成员，可以使用 public 修饰<br>\n隐藏成员，可以使用 private 修饰</p>\n<hr>\n<h4 id=\"实体类\"><a class=\"anchor\" href=\"#实体类\">#</a> 实体类</h4>\n<p>实体类的成员变量必须私有，且要为他们提供 get，set 方法；必须有无参构造器<br>\n仅仅只是一个用来保存数据的 java 类，可以用它创建对象，保存某个事物的数据</p>\n<p>实体类的应用场景：实体类对应的是软件开发里比较流行的开发方式 数据和数据的业务处理相分离</p>\n<hr>\n<h4 id=\"static\"><a class=\"anchor\" href=\"#static\">#</a> static</h4>\n<h5 id=\"变量\"><a class=\"anchor\" href=\"#变量\">#</a> 变量</h5>\n<p>叫静态，可以修饰成员变量、成员方法</p>\n<p>static 修饰的成员变量叫类变量（静态成员变量），<mark>类名。静态变量</mark>（推荐），对象名。静态变量（不推荐）</p>\n<p>无 static 修饰的成员变量叫实例变量（对象变量），属于对象，每个对象中都有一份。</p>\n<p>静态变量：数据只需要一份，且需要被共享时（访问，修改）<br>\n实例变量：每个对象都要有一份，数据各不同</p>\n<p>访问自己类中的类变量，可以省略类名不写，在某个类中访问其他类的类变量，必须带类名访问。</p>\n<h5 id=\"方法\"><a class=\"anchor\" href=\"#方法\">#</a> 方法</h5>\n<p>static 修饰的成员方法叫<mark>静态方法</mark>，属于类，可以直接用类名访问，也可以用对象访问<br>\n<mark>类名。静态方法（推荐）</mark><br>\n对象名。静态方法（不推荐）<br>\n无 static 修饰的成员方法叫<mark>实例方法</mark>（对象方法），属于对象只能用对象访问</p>\n<p>静态方法可以用来设计工具类<br>\n工具类中的方法都是<mark>静态方法</mark>，每个类方法都是用来完成一个功能<br>\n提高了代码的复用性；调用方便，提高了开发效率</p>\n<p>如果工具类使用实例方法，实例方法需要创建对象来调用，会<mark>浪费内存</mark></p>\n<p>工具类不需要创建对象，<mark>建议将工具类的构造器私有化</mark></p>\n<p>静态方法中可以直接访问静态成员，不可以直接访问实例成员<br>\n实例方法中既可以直接访问静态静态成员，也可以直接访问实例成员<br>\n实例方法中可以出现 this 关键字，静态方法中不可以出现 this 关键字</p>\n<hr>\n<h4 id=\"继承\"><a class=\"anchor\" href=\"#继承\">#</a> 继承</h4>\n<h5 id=\"继承-2\"><a class=\"anchor\" href=\"#继承-2\">#</a> 继承</h5>\n<p>java 中提供一个关键字 extends，用这个关键字可以让一个类与另一个类建立起父子关系</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子类能够继承父类的<mark>非私有成员</mark>（成员变量，成员方法）<br>\n子类的对象是由子类和父类共同完成的</p>\n<hr>\n<h5 id=\"权限修饰符\"><a class=\"anchor\" href=\"#权限修饰符\">#</a> 权限修饰符</h5>\n<p>用来限制类中的成员（成员变量，成员方法， 构造器）能够被访问的范围<br>\n private：只能本类<br>\n缺省：本类，同一个包中的类<br>\n protected：本类，同一个包中的类，子孙类中<br>\n public：任意位置</p>\n<p>修饰符\t\t\t本类\t\t同一个包中的类\t\t子孙类\t\t任意类<br>\n private\t\t\t1                             0                                  0                      0<br>\n 缺省\t\t\t     1                             1                                  0                      0\t<br>\nprotected                   1                             1                                  1                      0<br>\npublic                          1                             1                                  1                      1</p>\n<hr>\n<h5 id=\"继承的特点\"><a class=\"anchor\" href=\"#继承的特点\">#</a> 继承的特点</h5>\n<p>在子类方法中访问其他成员（成员变量，成员方法），是依照<mark>就近原则</mark>的<br>\n先在子类局部范围内找，然后子类成员范围内找，然后父类成员范围内找，如果父类范围还没有找到则报错。</p>\n<p>如果出现重名的成员，会优先使用子类，可以通过 ==super.== 关键字指定访问父类成员。</p>\n<p>java 中类是单继承的，一个类只能继承一个直接父类。</p>\n<p>object 是所有类的祖宗类。</p>\n<hr>\n<h5 id=\"方法重写\"><a class=\"anchor\" href=\"#方法重写\">#</a> 方法重写</h5>\n<p>当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称，参数列表一样的方法，去覆盖父类的这个方法。</p>\n<p>子类重写父类方法时，访问权限必须大于或等于父类该方法的权限<br>\n重写的方法返回值类型，必须与被重写方法的返回类型一样，或者范围更小<br>\n<mark>私有方法、静态方法</mark> 不能被重写，如果重写会报错。</p>\n<hr>\n<h5 id=\"子类构造器\"><a class=\"anchor\" href=\"#子类构造器\">#</a> 子类构造器</h5>\n<p>子类的全部构造器都会先调用父类的构造器，再执行自己</p>\n<p>默认情况下，子类全部构造器的第一行代码都是 super ()，他会调用父类的无参数构造器。<br>\n如果父类没有无参构造器，则我们必须在子类构造器的第一行手写 super，指定去调用父类的有参数构造器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">People</span>&#123;</span><br><span class=\"line\">\ta</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Teacher</span><span class=\"params\">(a, b, c)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">super</span>(b, c);</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.a = a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"this调用兄弟构造器\"><a class=\"anchor\" href=\"#this调用兄弟构造器\">#</a> this () 调用兄弟构造器</h5>\n<p>在任意类的构造器中，是可以通过 this (…) 去调用该类的其他构造器的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String schoolName;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>(name, <span class=\"string\">&quot;hhh&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name, String schoolName)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.schoolName = schoolName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this (…), super (…) 都只能放在构造器的第一行，因此，有了 this (…) 就不能写 super (…) 了，反之亦然</p>\n<hr>\n<h4 id=\"多态\"><a class=\"anchor\" href=\"#多态\">#</a> 多态</h4>\n<h5 id=\"认识多态\"><a class=\"anchor\" href=\"#认识多态\">#</a> 认识多态</h5>\n<p>多态是在继承 / 实现情况下的一种现象，表现为：对象多态，行为多态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">People</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">p1.run();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">People</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Teacher</span>();</span><br><span class=\"line\">p2.run();</span><br></pre></td></tr></table></figure>\n<p>多态的<mark>前提</mark>：有继承 / 实现关系；存在父类引用子类对象；<mark>存在方法重写</mark></p>\n<p>多态是<mark>对象，行为的多态</mark>，java 中的 == 属性（成员变量）== 不谈多态。</p>\n<hr>\n<h5 id=\"多态的好处\"><a class=\"anchor\" href=\"#多态的好处\">#</a> 多态的好处</h5>\n<p>在多态形式下，右边对象是解耦合的，更便于扩展和维护</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">People</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">p1.run();</span><br></pre></td></tr></table></figure>\n<p>定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强，更便利。</p>\n<p>多态下<mark>不能使用子类的独有功能</mark></p>\n<hr>\n<h5 id=\"多态下的类型转换\"><a class=\"anchor\" href=\"#多态下的类型转换\">#</a> 多态下的类型转换</h5>\n<p>自动类型转换：父类 变量名 = new 子类 ()；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">People</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Teacher</span>();</span><br></pre></td></tr></table></figure>\n<p>强制类型转换：子类 变量名 = (子类) 父类变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Teacher</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> (Teacher)p;</span><br></pre></td></tr></table></figure>\n<p>存在继承 / 实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。<br>\n运行时，如果发现对象的真实类型与强制转换后的类型不同，就会报<mark>类型准换异常</mark> (ClassCastException) 的错误出来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">People</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Teacher</span>();</span><br><span class=\"line\"><span class=\"type\">Student</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> (Student) p; <span class=\"comment\">// java.lang.ClassCastException</span></span><br></pre></td></tr></table></figure>\n<p><mark>强转前</mark>，java 建议：使用<mark> instanceof</mark> 关键字，判断当前对象的真实类型，再强制转换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p <span class=\"keyword\">instanceof</span> Student</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"final\"><a class=\"anchor\" href=\"#final\">#</a> final</h4>\n<h5 id=\"认识final\"><a class=\"anchor\" href=\"#认识final\">#</a> 认识 final</h5>\n<p>final 关键字是最终，可以修饰：类、方法、变量<br>\n修饰类：该类被称为最终类，特点是不能被继承了<br>\n修饰方法：该方法被称为最终方法，特点是不能被重写了<br>\n修饰变量：该变量有且仅有被赋值一次。</p>\n<p>final 修饰基本类型的变量，变量存储的<mark>数据</mark>不能被改变<br>\n final 修饰的引用类型的变量，变量存储的<mark>地址</mark> 不能被改变，但地址指向的对象内容可以改变</p>\n<p><mark>static final</mark> 修饰的成员变量被称为常量<br>\n作用：常用于记录系统的配置信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Constant</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SCHOOL_NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;船只教育&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><mark>变量名的命名规范：建议用大写英文单词，多个单词间使用下划线连接起来</mark></p>\n<p>使用常量记录系统配置信息的优势：代码可读性好，可维护性也好。<br>\n程序编译后，常量会被” 宏替换 “：出现常量的地方全部会被替换成其字面量。可以保证使用常量和直接使用字面量的性能是一样的。</p>\n<hr>\n<h5 id=\"单例类设计模式\"><a class=\"anchor\" href=\"#单例类设计模式\">#</a> 单例类（设计模式）</h5>\n<p>具体问题的最优解决方案，确保一个类只能创建一个对象。</p>\n<p>单例：把类的构造器私有，定义一个静态变量存储类的一个对象，提供一个静态方法返回对象。</p>\n<p>在任务管理器对象时，获取运行时对象。</p>\n<p>饿汉式单例：拿对象前，对象早就创建好了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"title function_\">A</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title function_\">getObject</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>懒汉式单例：拿对象时，才开始创建对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> B b;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"title function_\">B</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> B <span class=\"title function_\">getObject</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(b == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tb = <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"枚举类\"><a class=\"anchor\" href=\"#枚举类\">#</a> 枚举类</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\tX, Y, Z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举类都是最终类，不可以被继承，枚举类都是继承 java.lang.Enum 类的<br>\n枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量会记住枚举类的一个对象<br>\n枚举类的构造器都是私有的，因此，枚举类对外不能创建对象。<br>\n编译器对枚举类新增了几个方法。</p>\n<hr>\n<h5 id=\"枚举类的常见应用场景\"><a class=\"anchor\" href=\"#枚举类的常见应用场景\">#</a> 枚举类的常见应用场景</h5>\n<p>枚举类适合做信息分类和标致</p>\n<hr>\n<h5 id=\"抽象类\"><a class=\"anchor\" href=\"#抽象类\">#</a> 抽象类</h5>\n<p>关键字：<mark>abstract</mark>，可以用来修饰类，成员方法<br>\n abstract 修饰类，这个类就是抽象类<br>\n abstract 修饰方法，这个方法就是抽象方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> class 类名&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> 返回值 方法名();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类<br>\n类有的成员：成员变量，方法，构造器，抽象类都可以有<br>\n抽象类的<mark>主要特点</mark>：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现<br>\n一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</p>\n<hr>\n<h5 id=\"抽象类的好处\"><a class=\"anchor\" href=\"#抽象类的好处\">#</a> 抽象类的好处</h5>\n<p>父类知道每个子类要做的某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，设计这样的抽象类，就是为了更好的支持多态。</p>\n<hr>\n<h5 id=\"模板方法\"><a class=\"anchor\" href=\"#模板方法\">#</a> 模板方法</h5>\n<p>提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现<br>\n模板方法设计某事可以：提高代码的复用，并简化子类设计</p>\n<p>写法：<br>\n1、定义一个抽象类<br>\n 2、在里面定义 2 个方法<br>\n一个是<mark>模板方法</mark>，把共同的实现步骤放里面<br>\n一个是抽象方法：不确定的步骤，交给<mark>具体的子类实现</mark></p>\n<p>模板方法是给子类直接使用的，不能被子类重写，建议使用<mark> final 关键字</mark>修饰模板方法<br>\n一旦子类重写了模板方法，模板方法就失效了。</p>\n<hr>\n<h4 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h4>\n<h5 id=\"接口概述\"><a class=\"anchor\" href=\"#接口概述\">#</a> 接口概述</h5>\n<p>java 提供了一个关键字 interface 定义出接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> interface 接口名&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 成员变量（常量）</span></span><br><span class=\"line\">\t<span class=\"comment\">// 成员方法（抽象方法）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：<mark>接口不能创建对象</mark><br>\n接口是用来被<mark>实现的</mark>，实现接口的类型称为<mark>实现类</mark>，一个类可以实现多个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符 class 实现类名 implements 接口<span class=\"number\">1</span>、接口<span class=\"number\">2</span>、接口<span class=\"number\">3.</span>....&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义为抽象类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"接口好处\"><a class=\"anchor\" href=\"#接口好处\">#</a> 接口好处</h5>\n<p>弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大<br>\n让程序可以面向接口编程，更利于程序的解耦合。</p>\n<hr>\n<h5 id=\"接口新增的三种方法\"><a class=\"anchor\" href=\"#接口新增的三种方法\">#</a> 接口新增的三种方法</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 默认方法（实例方法）：使用default修饰，默认会被加public修饰</span></span><br><span class=\"line\">\t<span class=\"comment\">// 只能使用接口的实现类对象调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 私有方法：必须用private修饰</span></span><br><span class=\"line\">\t<span class=\"comment\">// 接口内部调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 类方法，使用static修饰，默认public</span></span><br><span class=\"line\">\t<span class=\"comment\">// 只能用接口名调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"接口的注意事项\"><a class=\"anchor\" href=\"#接口的注意事项\">#</a> 接口的注意事项</h5>\n<p>1、接口与接口可以多继承：一个接口可以继承多个接口<br>\n 2、一个接口继承多个接口，如果多个接口中存在方法签名冲突、则此时不支持多继承，也不支持多实现。<br>\n3、一个类继承了父类，又同时实现了接口，如果父亲中和接口中有同名的默认方法，实现类会先用父类的<br>\n 4、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类方法重写即可。</p>\n<hr>\n<h5 id=\"接口与抽象类\"><a class=\"anchor\" href=\"#接口与抽象类\">#</a> 接口与抽象类</h5>\n<p>相同点：<br>\n1、都是抽象形式，都可以有抽象方法，都不能创建对象。<br>\n2、都是派生子类形式，抽象类是被子类继承使用，接口是被实现类实现。<br>\n3、一个类继承抽象类，或者实现接口，都必须重写他们的抽象方法，否则自己称为抽象类或者报错。<br>\n4、都支持多态，能够实现解耦合<br>\n不同点：<br>\n1、抽象类中可以定义类的全部普通成员，接口只能定义常量，抽象方法（JDK8 新增的三种方法）<br>\n2、抽象类只能被类单继承，接口可以被类多实现。<br>\n3、一个类继承抽象类就不能继承其他类，一个接口实现了接口还可以继承其他类或者实现其他接口<br>\n 4、抽象类体现模板思想，更利于做父类，实现代码的复用<br>\n 5、接口更适合做功能的解耦合，解耦合性更灵活。</p>\n<h4 id=\"类中的成分\"><a class=\"anchor\" href=\"#类中的成分\">#</a> 类中的成分</h4>\n<h5 id=\"代码块\"><a class=\"anchor\" href=\"#代码块\">#</a> 代码块</h5>\n<p>代码块是类的 5 大成分之一（成员变量，构造器，方法，<mark>代码块</mark>，内部类）<br>\n代码块分为两种：<br>\n静态代码块：<br>\n格式：static {}<br>\n 特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。<br>\n作用：完成类的初始化，例如：对静态变量的初始化赋值。<br>\n实例代码块：<br>\n格式：{}<br>\n 特点：每次创建对象时，执行实例代码块，并在构造器前执行。<br>\n作用：和构造器一样，都是用来完成对象的初始化，例如：对实例变量进行初始化赋值</p>\n<hr>\n<h5 id=\"内部类\"><a class=\"anchor\" href=\"#内部类\">#</a> 内部类</h5>\n<p><mark>成员内部类</mark><br>\n就是类中的一个普通成员，类似前面学过的成员变量，成员方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建对象的格式</span></span><br><span class=\"line\">外部类名.内部类名 对象名 = <span class=\"keyword\">new</span> 外部类(...).new 内部类(...);</span><br><span class=\"line\">Outer.Inner in  <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>().<span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>成员内部类中访问其他成员的特点：<br>\n1、成员内部类中可以直接访问外部类的实例成员，静态成员。<br>\n2、成员内部类的实例方法中，可以直接拿到当前外部类对象，格式是：外部类名.this。</p>\n<p><mark>静态内部类</mark><br>\n有 static 修饰的内部类，属于外部类自己特有</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\">外部类.内部类名.对象名 = <span class=\"keyword\">new</span> 外部类.内部类(...);</span><br><span class=\"line\">Outer.Inner.in = <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.Inner();</span><br></pre></td></tr></table></figure>\n<p><mark>匿名内部类</mark><br>\n是一种特殊的局部内部类<br>\n所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类或接口(参数值...)&#123;</span><br><span class=\"line\">\t类体(一般是方法重写);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。<br>\n作用：用于更方便的创建子类对象。</p>\n<hr>\n<h5 id=\"lambda表达式\"><a class=\"anchor\" href=\"#lambda表达式\">#</a> lambda 表达式</h5>\n<p>可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(被重写方法的形参列表) -&gt; &#123;</span><br><span class=\"line\">\t被重写方法的代码体;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><mark>注意</mark>：lambda 表达式只能替代函数式接口的匿名内部类<br>\n函数式接口：有且仅有一个抽象方法的接口，注意大部分函数式接口上面都会有一个 @FunctionalInterface 的注释，用来注解用于约束当前接口必须是函数式接口。</p>\n<p>lambda 表达式的省略规则：<br>\n1、参数类型全部可以省略不写<br>\n 2、如果只有一个参数，参数类型省略的同时 () 也可以省略，但多个参数不能省略 ()<br>\n 3、如果 lambda 表达式中只有一行代码，大括号可以不写，同时要省略分号 &quot;;&quot; 如果这行代码是 return 语句，也必须去掉 return。</p>\n<hr>\n<h4 id=\"方法引用\"><a class=\"anchor\" href=\"#方法引用\">#</a> 方法引用</h4>\n<h5 id=\"静态方法引用\"><a class=\"anchor\" href=\"#静态方法引用\">#</a> 静态方法引用</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名::静态方法</span><br></pre></td></tr></table></figure>\n<p>使用场景：如果某个 Lambda 表达式只有一个静态方法，并且”-&gt;“前后参数的形式一致，就可以使用静态方法引用。</p>\n<hr>\n<h5 id=\"实例方法引用\"><a class=\"anchor\" href=\"#实例方法引用\">#</a> 实例方法引用</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象名::实例方法</span><br></pre></td></tr></table></figure>\n<p>使用场景：如果某个 Lambda 表达式里只是通过对象名称调用一个实例方法，并且 &quot;-&gt;&quot; 前后参数的形式一致，就可以使用实例方法引用。</p>\n<hr>\n<h5 id=\"特定类的方法应用\"><a class=\"anchor\" href=\"#特定类的方法应用\">#</a> 特定类的方法应用</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特定类的名称::方法</span><br></pre></td></tr></table></figure>\n<p>使用场景：如果某个 Lambda 表达式只是调用一个特定类型的实例方法，并且前面参数列表中的<mark>第一个参数</mark>是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。</p>\n<hr>\n<h5 id=\"构造器引用\"><a class=\"anchor\" href=\"#构造器引用\">#</a> 构造器引用</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名::<span class=\"keyword\">new</span></span><br></pre></td></tr></table></figure>\n<p>使用场景：如果某个 Lambda 表达式里只是在创建对象，并且”-&gt;“前后参数情况一致，就可以使用构造器引用。</p>\n<hr>\n<h3 id=\"常用api\"><a class=\"anchor\" href=\"#常用api\">#</a> 常用 API</h3>\n<h4 id=\"string-创建字符串对象的方式\"><a class=\"anchor\" href=\"#string-创建字符串对象的方式\">#</a> String 创建字符串对象的方式</h4>\n<ul>\n<li>方式一: Java 程序中的所有字符串文字 (例如 &quot;abc&quot;) 都为此类的对象.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方式二：调用 String 类的构造器初始化字符串对象</li>\n</ul>\n<h4 id=\"string-提供的常用方法\"><a class=\"anchor\" href=\"#string-提供的常用方法\">#</a> String 提供的常用方法</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回字符串的长度</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">length</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取某个索引的字符并返回</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">char</span> <span class=\"title function_\">charAt</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将当前字符串转换成字符数组返回</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">char</span>[] toCharArray()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前字符串与另一个字符串的内容一样，一样返回true</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object anObject)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断当前字符串与另一个字符串的内容一样，一样返回true(忽略大小写)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equalsIgnoreCase</span><span class=\"params\">(String anotherString)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据开始和结束索引来进行截取，得到新的字符串返回</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">substring</span><span class=\"params\">(<span class=\"type\">int</span> beginIndex)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用新的值， 将字符串中的旧值替换，得到新的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">replace</span><span class=\"params\">(CharSequence target, CharSequence replacement)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断字符串中是否包含了某个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(CharSequence s)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断字符串是否以某个字符串内容开头，开头返回true，反之</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startsWith</span><span class=\"params\">(String prefik)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把字符串按照某个字符串内容进行分割，并返回字符串数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String[] split(String regex)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"arraylist集合\"><a class=\"anchor\" href=\"#arraylist集合\">#</a> ArrayList 集合</h3>\n<p>常用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个空的集合对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将指定的元素添加到此集合的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在此集合中的指定位置插入指定的元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回指定元素索引处的元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回集合中元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定索引处的元素，返回被删除的元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定的元素，返回删除是否成功</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改指定索引处的元素，返回被修改的元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>\n<hr>\n",
            "tags": [
                "java",
                "java"
            ]
        },
        {
            "id": "http://gardencavy.site/hello-world/",
            "url": "http://gardencavy.site/hello-world/",
            "title": "Hello World",
            "date_published": "2025-01-13T10:41:34.161Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}